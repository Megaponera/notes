# 迪杰斯特拉（Dijkstra）算法

![](C:\C++学习资料\学习笔记\路径图.png)

该路径图的带权可达矩阵为WD( **-** 代表无穷大):

| vi\vj | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0     | 0    | 5    | 3    | -    | -    | -    | -    | -    | -    | -    | -    | -    | -    |
| 1     |      | 0    | -    | 1    | 3    | 5    | -    | -    | -    | -    | -    | -    | -    |
| 2     |      |      | 0    | -    | 8    | 7    | 6    | -    | -    | -    | -    | -    | -    |
| 3     |      |      |      | 0    | -    | -    | 6    | 5    | -    | -    | -    | -    | -    |
| 4     |      |      |      |      | 0    | -    | 3    | 5    | -    | -    | -    | -    | -    |
| 5     |      |      |      |      |      | 0    | -    | 3    | 3    | -    | -    | -    | -    |
|       |      |      |      |      |      |      | 0    | 8    | 4    | -    | -    | -    | -    |
| 7     |      |      |      |      |      |      |      | 0    | -    | 3    | 5    | -    | -    |
| 8     |      |      |      |      |      |      |      |      | 0    | 5    | 2    | -    | -    |
| 9     |      |      |      |      |      |      |      |      |      | 0    | 3    | 6    | -    |
| 10    |      |      |      |      |      |      |      |      |      |      | 0    | -    | 4    |
| 11    |      |      |      |      |      |      |      |      |      |      |      | 0    | 3    |
| 12    |      |      |      |      |      |      |      |      |      |      |      |      | 0    |

#### 实现过程

初始数据：

当前可达路径数组：D = { - , - , - , - , - , - , - , - , - , - , - , - }

最优路径数组：P = { - , - , - , - , - , - , - , - , - , - , - , - } 

最优路径数组存放的值代表从0到i结点的最优路径上，i的上一个结点的编号

记录数组：F = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

用来记录该结点是否已经得出最短路径，1代表已经得出

1. 从0出发，将0的带权可达矩阵加入到当前可达路径数组D中（0不纳入考虑），即D = {5 , 3 , - , - , - , - , - , - , - , - , - , -}，并将数组P置为   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
2. 找到D中最小的权值W以及对应的结点vex，且vex的在F数组中的值不为1，则将F[vex - 1]置为1，代表0到vex结点的最短路径已得出。
   例如：此时W对应2号结点的3，F = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }，即0到2结点的最短路径已得出
3. 通过步骤2得到的结点vex以及其带权可达矩阵，更新数组D；将带权可达矩阵的值与vex在D中的权值之和，与D中对应点的权值相比，若满足对应点在F中的值不为1且( WD[vex] [j] + D[vex]) < D[j]，则替换D[j]为( WD[vex] [j] + D[vex])；若D中的值被替换，则将P中的相应位置的值，替换为vex，代表从0到该点的最短路径，需要经过vex
   例如：将得出0到2的最短路径后，更新D = {5 , 3 , - , 3+8 , 3+7 , 3+6 , - , - , - , - , - , -}，P = { 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0 }
4. 重复步骤2，3，直到F中不存在0为止



当前可达路径矩阵：

- 矩阵中有3种类型的值：
  - a(b,c)	从0到c的总权值为a，从0到c的最短路径中，c的上一个结点为b（b有可能就是0号结点）
  - " - "       该结点当前无法到达，- 代表无穷大 
  - [a]         从0到该结点的最短路径已经得出，最短路径的权值为a

| 1            | 2            | 3            | 4            | 5             | 6            | 7             | 8             | 9             | 10             | 11             | 12              |
| ------------ | ------------ | ------------ | ------------ | ------------- | ------------ | ------------- | ------------- | ------------- | -------------- | -------------- | --------------- |
| 5(0,1)       | ***3(0,2)*** | -            | -            | -             | -            | -             | -             | -             | -              | -              | -               |
| ***5(0,1)*** | [3]          | -            | 11(2,4)      | 10(2,5)       | 9(2,6)       | -             | -             | -             | -              | -              | -               |
| [5]          | [3]          | ***6(1,3)*** | 8(1,4)       | 10(2,5)       | 9(2,6)       | -             | -             | -             | -              | -              | -               |
| [5]          | [3]          | [6]          | ***8(1,4)*** | 10(2,5)       | 9(2,6)       | 12(3,7)       | 14(3,8)       | -             | -              | -              | -               |
| [5]          | [3]          | [6]          | [8]          | 10(2,5)       | ***9(2,6)*** | 11(4,7)       | 13(4,8)       | -             | -              | -              | -               |
| [5]          | [3]          | [6]          | [8]          | ***10(2,5)*** | [9]          | 11(4,7)       | 13(4,8)       | 13(6,9)       | -              | -              | -               |
| [5]          | [3]          | [6]          | [8]          | [10]          | [9]          | ***11(4,7)*** | 13(4,8)       | 13(6,9)       | -              | -              | -               |
| [5]          | [3]          | [6]          | [8]          | [10]          | [9]          | [11]          | ***13(4,8)*** | 13(6,9)       | 14(7,10)       | 16(7,11)       | -               |
| [5]          | [3]          | [6]          | [8]          | [10]          | [9]          | [11]          | [13]          | ***13(6,9)*** | 14(7,10)       | 15(8,11)       | -               |
| [5]          | [3]          | [6]          | [8]          | [10]          | [9]          | [11]          | [13]          | [13]          | ***14(7,10)*** | 15(8,11)       | -               |
| [5]          | [3]          | [6]          | [8]          | [10]          | [9]          | [11]          | [13]          | [13]          | [14]           | ***15(8,11)*** | 18(10,12)       |
| [5]          | [3]          | [6]          | [8]          | [10]          | [9]          | [11]          | [13]          | [13]          | [14]           | [15]           | ***18(10,12)*** |

##### 最短路径长度数组：D = { 5, 3, 6, 8, 10, 9, 11, 13, 13, 14, 15, 18 }

最短路径矩阵：

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 0    | 2    | 2    | 2    | 0    | 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 2    | 2    | 2    | 0    | 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 3    | 3    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 7    | 7    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 7    | 8    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 7    | 8    | 0    |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 7    | 8    | 10   |
| 0    | 0    | 1    | 1    | 2    | 2    | 4    | 4    | 6    | 7    | 8    | 10   |

##### 最短路径数组：P = { 0, 0, 1, 1, 2, 2, 4, 4, 6, 7, 8, 10 }

#### 输出最短路径（0到K号结点的最短路径）：

1. 记当前所在最短路径的位置为index（初始index = K）
2. 如果D[index]不为0，将index加入到路径中，否则输出路径
3. index = D[index]
4. 重复步骤2，3