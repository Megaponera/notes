# 单例模式

在一个程序中，类只存在一个实例

实现方法

将类的构造函数以及拷贝构造函数设为私有成员，在类内定义一个该类的static类型的指针数据成员，使其在程序编译时就构造了唯一的实例



# 虚析构函数以及纯虚析构函数

在多态的前提条件下，将子类指针或对象的引用赋值给父类指针或引用，可以该父类指针或引用可以调用子类的override的虚成员函数。但当该父类指针释放时，若父类的析构函数不是虚函数，该父类只会调用父类的析构函数，从而导致该指针包含的子类的部分没能够释放，造成内存泄漏。

若父类的析构函数为虚函数，在父类指针释放时，会先检查RTTI，确定该指针指向的是父类对象，还是子类对象。若为子类对象，会先调用子类的析构函数，再调用父类的析构函数，从而防止内存泄漏。

```
class Base{ virtual ~Base(){} };
class Dervice : Base { ~Dervice(){} };
class DDervice : public Dervice{ ~DDervice(){} };

Base *b1 = new Dervice();
Base *b2 = new DDervice();
b1->~Base();
b2->~Base();
```

由于公共基类Base定义了虚析构函数，所以其子类的析构函数默认也是virtual类型的，因此b1调用基类的析构函数时，会先调用Dervice的析构函数，然后再调用Base的析构函数；而b2则会先调用DDervice的析构函数，再调用Dervice的析构函数，最后再调用Base的析构函数。

若基类的析构函数定义为纯虚析构函数，则该类为抽象类（或称为虚基类）。